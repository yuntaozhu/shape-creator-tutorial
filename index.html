<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MediaPipe + Three.js Shape Creator</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
    }
    #webcam, #canvas, #three-canvas {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      object-fit: cover;
      pointer-events: none;
      transform: scaleX(-1);
    }
    #recycle-bin {
      position: absolute;
      bottom: 60px;
      right: 60px;
      width: 160px;
      height: 160px;
      z-index: 20;
      pointer-events: none;
    }
    #recycle-bin.active {
      filter: drop-shadow(0 0 10px #ff0000);
      transform: scale(1.1);
      transition: transform 0.2s, filter 0.2s;
    }
  </style>
</head>
<body>
  <video id="webcam" autoplay muted playsinline></video>
  <canvas id="canvas"></canvas>
  <div id="three-canvas"></div>
  <img id="recycle-bin" src="recyclebin.png" alt="Recycle Bin" />

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let video = document.getElementById('webcam');
    let canvas = document.getElementById('canvas');
    let ctx = canvas.getContext('2d');
    let scene, camera, renderer;
    let shapes = [];
    let currentShape = null;
    let isPinching = false;
    let shapeScale = 1;
    let originalDistance = null;
    let selectedShape = null;
    let shapeCreatedThisPinch = false;
    let lastShapeCreationTime = 0;
    const shapeCreationCooldown = 1000;

    const initThree = () => {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;
      renderer = new THREE.WebGLRenderer({ alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('three-canvas').appendChild(renderer.domElement);
      const light = new THREE.AmbientLight(0xffffff, 1);
      scene.add(light);
      animate();
    };

    const animate = () => {
      requestAnimationFrame(animate);
      shapes.forEach(shape => {
        if (shape !== selectedShape) {
          shape.rotation.x += 0.01;
          shape.rotation.y += 0.01;
        }
      });
      renderer.render(scene, camera);
    };

    const neonColors = [0xFF00FF, 0x00FFFF, 0xFF3300, 0x39FF14, 0xFF0099, 0x00FF00, 0xFF6600, 0xFFFF00];
    let colorIndex = 0;

    const getNextNeonColor = () => {
        const color = neonColors[colorIndex];
        colorIndex = (colorIndex + 1) % neonColors.length;
        return color;
    };

    const createRandomShape = (position) => {
      const geometries = [
        new THREE.BoxGeometry(),
        new THREE.SphereGeometry(0.5, 32, 32),
        new THREE.ConeGeometry(0.5, 1, 32),
        new THREE.CylinderGeometry(0.5, 0.5, 1, 32)
      ];
      const geometry = geometries[Math.floor(Math.random() * geometries.length)];
      const color = getNextNeonColor();
      const group = new THREE.Group();

      const material = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.5 });
      const fillMesh = new THREE.Mesh(geometry, material);

      const wireframeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
      const wireframeMesh = new THREE.Mesh(geometry, wireframeMaterial);

      group.add(fillMesh);
      group.add(wireframeMesh);
      group.position.copy(position);
      scene.add(group);

      shapes.push(group);
      return group;
    };

    const get3DCoords = (normX, normY) => {
      const x = (normX - 0.5) * 10;
      const y = (0.5 - normY) * 10;
      return new THREE.Vector3(x, y, 0);
    };

    const isPinch = (landmarks) => {
      const d = (a, b) => Math.hypot(a.x - b.x, a.y - b.y, a.z - b.z);
      return d(landmarks[4], landmarks[8]) < 0.07;
    };

    const areIndexFingersClose = (l, r) => {
      const d = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
      return d(l[8], r[8]) < 0.12;
    };

    const isFist = (landmarks) => {
      const d = (a, b) => Math.hypot(a.x - b.x, a.y - b.y, a.z - b.z);
      return d(landmarks[4], landmarks[8]) < 0.05 && d(landmarks[4], landmarks[12]) < 0.07;
    };

    const findNearestShape = (position) => {
      let minDist = Infinity;
      let closest = null;
      shapes.forEach(shape => {
        const dist = shape.position.distanceTo(position);
        if (dist < 1.5 && dist < minDist) {
          minDist = dist;
          closest = shape;
        }
      });
      return closest;
    };

    const isInRecycleBinZone = (position) => {
      const vector = position.clone().project(camera);
      const screenX = ((vector.x + 1) / 2) * window.innerWidth;
      const screenY = ((-vector.y + 1) / 2) * window.innerHeight;

      const binWidth = 160;
      const binHeight = 160;
      const binLeft = window.innerWidth - 60 - binWidth;
      const binTop = window.innerHeight - 60 - binHeight;
      const binRight = binLeft + binWidth;
      const binBottom = binTop + binHeight;

      const adjustedX = window.innerWidth - screenX;

      return adjustedX >= binLeft && adjustedX <= binRight && screenY >= binTop && screenY <= binBottom;
    };

    const hands = new Hands({ locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });

    hands.onResults(results => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const recycleBin = document.getElementById('recycle-bin');

      for (const landmarks of results.multiHandLandmarks) {
        const drawCircle = (landmark) => {
          ctx.beginPath();
          ctx.arc(landmark.x * canvas.width, landmark.y * canvas.height, 10, 0, 2 * Math.PI);
          ctx.fillStyle = 'rgba(0, 255, 255, 0.7)';
          ctx.fill();
        };
        drawCircle(landmarks[4]); // Thumb tip
        drawCircle(landmarks[8]); // Index tip
      }

      // Existing shape interaction and gesture logic...
      if (results.multiHandLandmarks.length === 2) {
        const [l, r] = results.multiHandLandmarks;
        const leftPinch = isPinch(l);
        const rightPinch = isPinch(r);
        const indexesClose = areIndexFingersClose(l, r);

        if (leftPinch && rightPinch) {
          const left = l[8];
          const right = r[8];
          const centerX = (left.x + right.x) / 2;
          const centerY = (left.y + right.y) / 2;
          const distance = Math.hypot(left.x - right.x, left.y - right.y);

          if (!isPinching) {
            const now = Date.now();
            if (!shapeCreatedThisPinch && indexesClose && now - lastShapeCreationTime > shapeCreationCooldown) {
              currentShape = createRandomShape(get3DCoords(centerX, centerY));
              lastShapeCreationTime = now;
              shapeCreatedThisPinch = true;
              originalDistance = distance;
            }
          } else if (currentShape && originalDistance) {
            shapeScale = distance / originalDistance;
            currentShape.scale.set(shapeScale, shapeScale, shapeScale);
          }
          isPinching = true;
          recycleBin.classList.remove('active');
          return;
        }
      }

      isPinching = false;
      shapeCreatedThisPinch = false;
      originalDistance = null;
      currentShape = null;

      if (results.multiHandLandmarks.length > 0) {
        for (const landmarks of results.multiHandLandmarks) {
          const indexTip = landmarks[8];
          const position = get3DCoords(indexTip.x, indexTip.y);

          if (isFist(landmarks)) {
            if (!selectedShape) {
              selectedShape = findNearestShape(position);
            }
            if (selectedShape) {
              selectedShape.position.copy(position);

              const inBin = isInRecycleBinZone(selectedShape.position);
              selectedShape.children.forEach(child => {
                if (child.material && child.material.wireframe) {
                  child.material.color.set(inBin ? 0xff0000 : 0xffffff);
                }
              });
              if (inBin) {
                recycleBin.classList.add('active');
              } else {
                recycleBin.classList.remove('active');
              }
            }
          } else {
            if (selectedShape && isInRecycleBinZone(selectedShape.position)) {
              scene.remove(selectedShape);
              shapes = shapes.filter(s => s !== selectedShape);
            }
            selectedShape = null;
            recycleBin.classList.remove('active');
          }
        }
      } else {
        if (selectedShape && isInRecycleBinZone(selectedShape.position)) {
          scene.remove(selectedShape);
          shapes = shapes.filter(s => s !== selectedShape);
        }
        selectedShape = null;
        recycleBin.classList.remove('active');
      }
    });

    const initCamera = async () => {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
      video.srcObject = stream;
      await new Promise(resolve => video.onloadedmetadata = resolve);
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      new Camera(video, {
        onFrame: async () => await hands.send({ image: video }),
        width: video.videoWidth,
        height: video.videoHeight
      }).start();
    };

    initThree();
    initCamera();
  </script>
</body>
</html>